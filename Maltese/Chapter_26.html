<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Chapter 26 - Maltese Cross</title>
	<link rel="stylesheet" type="text/css" href="../libs/style.css">
	<link rel="stylesheet" type="text/css" href="../libs/prettify.css">
	<script src="../libs/run_prettify.js?autoload=true&amp;lang=css" defer=""></script>
	<script type="text/javascript" src="../libs/three.js"></script>
	<script type = "text/javascript" src = "../libs/dat.gui.js"></script>
	<script src = "../libs/OrbitControls.js"></script>
	<script src = "../libs/WebGeometry.js"></script>
	<script src = "../libs/polyhedron.js"></script>
	<script src = "maltese_verts.js"></script>
	<script src = "maltese.js"></script>
	
	<style>
		#div_out_big
		{
			position: relative;
			width: 1075px;
			height: 525px;
			left: 0px;
			background-color: #aaffff;
			border: solid 2px;
		}
		#div_in_big
		{
			position: absolute;
			left: 5px;
			top: 5px;			
			height: 410px;
			width: 1145px;
			background-color: #eeffee;
			border: solid 2px;
		}
		#div_pars_big
		{
			position: absolute;
			left: 530px;
			top: 2px;			
			height: 515px;
			width: 280px;
			background-color: #eeeeaa;
			border: solid 2px;
		}
		#gui_container_big
		{
			position: absolute;
			left: 820px;
			top: 5px;
		}
	</style>
</head>

<body>

<h3 align = "center">&emsp;&emsp;
<a href="../Cushion/Chapter_25.html"> <span class=brown>Глава 25 </span></a>  <span class=brown>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=brown> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=brown>► &ensp;</span><a href="../Octagram/Chapter_27.html"> <span class=brown> Глава 27  </span></a>
</h3>

<h2 align = "center"> Three.js и геометрия.  &ensp; Глава 26. &ensp; Мальтийский крест (<em>Maltese Cross</em>)</h2>

<p>
В данном разделе мы создадим модель огранки, которая носит название 
<b><a href="http://diamond3d.ucoz.ru/Maltese/CushionMalt_wireframe_trackball.html" target="_blank">мальтийский крест</a></b>.
По ссылке  <b><a href="http://diamond3d.ucoz.ru/Dispersion/CushionMaltese_D.html" target="_blank">Maltese - Light Dispersion</a></b>  
можно увидеть многогранник отображенный при помощи кубических карт. При нажатии на приведенной по ссылке 
странице кнопки <b>Inverse</b> многогранник отобразится на черном фоне.
<br>
&emsp;Построим многогранник, внешний вид которого можно увидеть в online-программе. Его рундист является линией по форме
напоминающей "подушку". Построение линии данного рундиста было подробно рассмотрено в предыдущих главах.
Павильон многогранника своим внешним видом напоминает мальтийский восьмиконечный крест (<b>Maltese Cross</b>).
Поэтому назовем огранку <em>Cushion Maltese Cross Cut</em> или просто <em>Maltese</em>.

Павильон многогранника содержит <b>48 граней</b>, а корона <b>32</b> грани без учета площадки.  Будем считать, что у данной огранки 
длина равна (или примерно равна) ее ширине. Это означает, что удлинение огранки (параметр <b>lw</b>) равно <b>1.0</b> 
или отклоняется от <b>1.0</b> на незначительную величину.  Такую огранку можно, очень условно, назвать "квадратной" огранкой. 
</p>
<div id="div_out_big"> 
		<canvas id="canvas" width="522" height="522" style="border: 1px solid"></canvas>
		<div id="div_pars_big" >
			<canvas id="canvas_pars" width="280" height="480"></canvas>
			<div id="div_input">
				                     <input type="radio" name="numeration" id = "btn_no"  />No
				&nbsp&nbsp&nbsp&nbsp <input type="radio" name="numeration" id = "btn_all" />All
				&nbsp&nbsp&nbsp&nbsp <input type="radio" name="numeration" id = "btn_cr_gd_pav"  />Cr-Gd-Pav
			</div>		
		</div>
		<div id="gui_container_big" ></div> 
</div>
<h3 align = "center"> Нумерация вершин и обозначение граней модели </h3>
<p>
Схематичные изображения короны и павильона огранки, а также нумерация вершин показаны на рисунках <b>1</b> и <b>2</b>. 
Рисунок <b>1</b> отображает вид многогранника когда наблюдатель находится <em>снаружи</em> модели и смотрит на корону 
<em>сверху</em>. На рисунке <b>2</b> наблюдатель смотрит на павильон <em>сверху</em>
как если бы он находился <em>внутри</em> модели. 
</p>
<img src = "Maltese_png_01.png" class="center-img-rounded" border = "2px" >

<h3 align = "center"> Структура данных модели (<b>СДМ</b>) многогранника  </h3>
&nbsp; &nbsp; <b>СДМ</b> содержит следующие параметры:
<pre class="prettyprint" id="quine">
var lw = 1.0;           // Отношение длины к ширине
// Рундист
var r = 0.040;          // Толщина рундиста
// Для следующих трех полей в dat.GUI не будем вводить параметры
// Эти три поправки введены для получения более равномерного по толщине рундиста
var del_gd_1 = 0.013;   // изменяет глубину рундиста в его вершинах g64, g80 ...
var del_gd_2 = 0.004;   // изменяет глубину рундиста в его вершинах g72, g88 ...
var del_gd_3 = -0.003;  // изменяет глубину рундиста в его вершинах g68, g76 ...
// Форма рундиста задается точно также как в Girdle1_A.html и Girdle1_B.html
var rounnd_cir1 = 0.114;        // "Roundness front"
var rounnd_cir2 = 0.114;        // "Roundness flank"
var R3 = 0.034;                 // "Radius corner"
// Расстановка вершин на рундисте задается также как в Girdle1_B.html
var ang_2 = 38*DEGREE;          // "Front angle girdle"
var ang_3 = 38*DEGREE;          // "Flank angle girdle"
var ang_corner = 45.0*DEGREE;   // "Corner angle girdle""
var gd_segments = 0.18;         // Основной параметр задающий размеры сегментов
// Корона
var beta = 35*DEGREE;         // Угол наклона короны к горизонтальной плоскости
var t = 0.60;                 // Размер площадки
var starFacets = 0.5;         // Star facets
// Павильон
var hp1 = 0.32;               // "Pavilion depth level 1  (hp1) "
var hp2 = 0.163;              // "Pavilion depth level 2  (hp2) "
var del_hp1 = 0.020;           //  Смотри текст программы
var pav_ang_a = 54*DEGREE;    // Угол наклона грани a павильона
var pav_ang_b = 41.9*DEGREE;  // Угол наклона грани b павильона
var pav_ang_c = 54*DEGREE;    // Угол наклона грани c павильона
var hA0 = 0.192;              // Глубина центральных вершины на гранях a и b 
var hA1 = 0.09;               // Глубина боковых вершины на гранях a, b и c
</pre>

<h3 align = "center"> Расчет положения вершин короны  </h3>
<p>
Корону многогранника "подушка" можно было бы построить аналогично тому, как строится корона круглого бриллианта. 
Однако, из-за значительного отличия формы рундиста "подушки" от формы рундиста круглого бриллианта, 
рисунок короны при таком построении окажется не слишком красивым. Поэтому для создания короны огранки "подушка" 
обычно используется совершенно иной способ ее построения. Прежде всего, требуется определить основные требования к рисунку короны.  
Под этим понимается расположение одних ребер и граней короны относительно других ее граней и ребер, 
а также относительно граней и ребер рундиста. Желательно построить корону таким образом, чтобы ребра (рис.<b>1</b>)
сединяющие вершину короны <b>8</b> с вершиной рундиста <b>4</b> и вершину короны <b>9</b> с вершиной рундиста <b>12</b> 
(а также ребра аналогичные этим ребрам в других квадрантах огранки) подходили к линии рундиста под прямым углом. 
Угловая грань <b>B</b> должна по возможности оставаться симметричной относительно прямой, проведенной через вершину 
короны <b>1</b> и рундиста <b>8</b>, при изменении удлинения огранки. Это же относится и к трем другим угловым граням короны.
</p>
<p>
При построении короны многогранника "подушка" возникают значительные трудности с внесением в число его параметров  
параметра <b>Star facets</b> (определение этого параметра приведено в главе в которой создавалась модель бриллианта)
таким образом, чтобы он был не только параметром "read-only", но и мог использоваться для задания соответствующего
значения параметра. При построении огранок бриллиант, маркиз, груша и сердце параметр <b>Star facets</b>  рассчитывался
при помощи другого параметра <b>Square table</b>, которому соответствует поле dSquare в структуре данных огранки (<b>СДМ</b>).
Параметр <b>Star facets</b>  при таком подходе собственного поля в <b>СДМ</b> не имеет. Значение параметра <b>dSquare</b>  естественным 
образом связано со способом построения перечисленных огранок, так как задает основные пропорции короны.  
Только в огранке <em>Marquise</em> (первый вариант построения короны этой огранки) она была построена без использования 
параметра <b>Square table</b>. В ней значение параметра <b>Star facets</b> рассчитывалось напрямую, без использования 
значения <b>dSquare</b>. Такое построение короны огранки <em>Marquise</em> было сделано в основном для того, 
чтобы показать, что существуют и другие подходы к созданию корон огранок, которые не требуют  введения величины
параметра <b>dSquare</b> в <b>СДМ</b>. 
При построении в данном разделе короны многогранника "подушка" параметр <b>Star facets</b> будет введен 
в число параметров напрямую и, поэтому, он получит собственное поле <code>starFacets</code> в <b>СДМ</b>. 
Значительная часть программы построения короны предназначена как раз для того, чтобы обеспечить возможность 
работы с этим параметром. 
<br>

&emsp;Будем считать, что положение узловых вершин рундиста со стороны короны уже найдено в процессе работы функции
вычисляющей координаты вершин рундиста (смотри <b>Girdle1_B.html</b>). Перейдем к поэтапному рассмотрению 
построения короны многогранника.
</p>
<p>
Прежде всего, определяются уравнения плоскостей, в которых лежат грани <b>A, B</b> и <b>C</b> короны. 
Для их нахождения необходимо задать углы наклона этих плоскостей к горизонтальной плоскости. Примем в качестве
значения угла наклона всех трех плоскостей значение параметра <b>Crown angle</b>, которому в структуре данных модели 
соответствует переменная <code>beta</code>. Таким образом, параметр <b>Crown angle</b> одновременно и одинаковым 
образом меняет наклон граней <b>A</b> и <b>C</b>. Мы задали наклон угловой грани <b>B</b> также равным 
углу <code>beta</code>, но в ходе дальнейшего построения огранки это значение будет пересчитано и 
наклон угловой грани <b>B</b> станет отличаться от углов наклона граней <b>A</b> и <b>C</b>. 
</p>

<p>
Плоскости граней <b>A, B</b> и <b>C</b> проходят через вершины рундиста <b>0, 8</b> и <b>16</b>. Расчет уравнений плоскостей осуществляется при помощи
функции <code>Facet</code> (можно использовать и функцию <code>CreateInclinePlane</code>).
<br>
На следующем этапе находится уравнение горизонтальной плоскости, в которой лежит площадка короны. 
Нетрудно убедиться, в том, что значение высоты площадки рассчитывается по следующей формуле 
<br>
&emsp;&emsp;0.5 <b>·</b> tan (<em>угол_короны</em>) <b>·</b> (1 – <em>ширина_площадки</em>) + <em>толщина_рундиста</em>/2.
<p>
Затем находим уравнения плоскостей, проходящих перпендикулярно к линиям касательным к рундисту  в его узловых вершинах 
<b>0, 8, 16</b>, а также <b>4</b> и <b>12</b>. Это плоскости <b>pl_normal_g0, pl_normal_g4 ... pl_normal_g16</b>. 
Координаты вершин короны <b>0, 1</b> и <b>2</b> находим как точки пересечения трех плоскостей. 
Для определения положения вершины <b>0</b> короны берутся плоскость грани <b>A</b>, <b>pl_normal_g0</b> и плоскость площадки. 
Для определения положения вершины <b>1</b> короны берутся плоскости <b>B, pl_normal_g8</b> и плоскость площадки, 
а для вершины <b>2</b> – берутся плоскости <b>C, pl_normal_g16</b> и плоскость площадки. Следует особо подчеркнуть тот факт, 
что координаты короны <b>1</b> являются предварительными и в ходе дальнейших вычислений будут пересчитаны.
Положение вершин короны <b>8</b> и <b>9</b> должно быть определено с учетом значения параметра <b>starFacets</b>. 
Прежде всего найдем прямую <b>ln_A_B</b> по которой пересекаются плоскости в которых лежат грани <b>A</b> и <b>B</b>.
</p>
<p>
Построим две вспомогательные вертикальные плоскости. 
Одна из них будет через вершину рундиста <b>4</b> и <em>касаться</em> линии рундиста в этой вершине. 
Вторая вертикальная плоскость будет проходить через вершину короны <b>0</b> и найденное 
предварительное положение вершины короны <b>1</b>. После этого определим координаты точек пересечения 
прямой по которой пересекаются плоскости <b>A</b> и <b>B</b> короны с этими двумя вертикальными плоскостями. 
Эти две точки найденные точки ограничивают собой отрезок на прямой, по которой пересекаются плоскости <b>A</b> и <b>B</b>. 
Значение параметра <b>Star facets</b> определяет, в каком отношении вершина короны <b>8</b> делит этот 
отрезок на две части. Заметим, что на следующем шаге мы несколько скорректируем положение вершины 
короны <b>8</b> в горизонтальной плоскости (но не тронем значение ее высоты) и поэтому положение вершины <b>8</b>, 
также как и положение вершины <b>1</b> короны, пока считаем предварительным. 
Нам от вершины <b>8</b> требуется только значение ее высоты. Эта высота определит положение  горизонтальной плоскости, 
на которой расположены все вершины средней части короны – <b>8, 9, 10, 11, 12, 13, 14, 15</b>. 
Заметим, что все эти вершины должны обязательно иметь одинаковую высоту (координату по оси <b>OZ</b>).  
</p>
<p>
Теперь можно перейти к нахождению окончательных координаты вершин короны <b>8</b> и <b>9</b>. Вершину короны <b>8</b> 
получаем как точку пересечения трех плоскостей – горизонтальной плоскости, на которой расположены вершины средней части короны, 
плоскости <b>A</b> и вертикальной плоскости проходящей перпендикулярно к рундисту в его вершине <b>4</b>. 
Вершину короны <b>9</b> получаем как точку пересечения трех плоскостей – той же горизонтальной плоскости, 
плоскости <b>C</b> и вертикальной плоскости проходящей перпендикулярно к рундисту в его вершине <b>12</b>.
</p>
<p>
На следующем этапе построения короны находим новое уравнение плоскости, в которой лежит грань <b>B</b>. 
Уравнение плоскости определяем по трем ее вершинам – вершине рундиста <b>8</b> и вершинам короны <b>8</b> и <b>9</b>.
Последнее, что требуется сделать – это пересчитать положение вершины <b>1</b> короны в горизонтальной плоскости 
(по оси <b>OX</b> и <b>OY</b>).  Для пересчета создаем плоскость перпендикулярную плоскости <b>OXY</b>, 
проходящую через две точки. Одна из этих точек – это вершина рундиста <b>8</b>. Другая точка – эта точка, 
координаты которой по осям <b>OX</b> и <b>OY</b> представляют собой среднее арифметическое координат вершин 
короны <b>8</b> и <b>9</b> по этим же осям. Новое значение положения вершины <b>1</b> находим как точку пересечения 
созданной только что вертикальной плоскости, плоскости в которой лежит площадка огранки, 
и плоскости в которой лежит грань <b>B</b>. Эта вертикальная плоскость строится по трем точкам, 
две из которых <b>pt_mid_1</b> и <b>pt_mid_2</b> расположены на одной вертикальной прямой.
Остальные вершины короны находятся из соображений симметрии огранки. 
Из приведенного описания построения короны видно, что основная сложность при создании огранки 
действительно заключается в реализации приемлемой работы параметра <b>Star facets</b>.  
Если в данной огранке от него отказаться и заменить его высотой плоскости, 
на которой лежат средние вершины короны  <b>8, 9, . . . 15</b>, то построение огранки 
значительно упростится, но внешний вид короны сверху в этом случае будет определяться 
косвенно через задание высоты, на которой лежит эта горизонтальная плоскость.
</p>
<pre class="prettyprint" id="quine">
	InitGirdle();
	
	var i;
	var nCrown  = 16;
	var nGirdle = 64;
	var nPav    = 21;

	// Для большей равномерности толщины рундиста со стороны павильона
	// делаем небольшие добавки (+/-) к значению величины -r/2
	var  d1 = del_gd_1;
	girdle[64+0][2] = -r/2 + d1;
	girdle[64+16][2] = -r/2 + d1;
	girdle[64+32][2] = -r/2 + d1;
	girdle[64+48][2] = -r/2 + d1;

	var d2 = del_gd_2;
	girdle[64+8][2] = -r/2 + d2;
	girdle[64+24][2] = -r/2 + d2;
	girdle[64+40][2] = -r/2 + d2;
	girdle[64+56][2] = -r/2 + d2;

	var d3 = del_gd_3;
	girdle[64+4][2] = -r/2 + d3;
	girdle[64+12][2] = -r/2 + d3;
	girdle[64+20][2] = -r/2 + d3;
	girdle[64+28][2] = -r/2 + d3;
	girdle[64+36][2] = -r/2 + d3;
	girdle[64+44][2] = -r/2 + d3;
	girdle[64+52][2] = -r/2 + d3;
	girdle[64+60][2] = -r/2 + d3;

	var X1 = new Vector3D(1, 0, 0);
	var Y1 = new Vector3D(0, 1, 0);
	var Z1 = new Vector3D(0, 0, 1);
	
	// Плоскости в которых лежат грани короны A, B и C.
	var A = Facet(beta, girdle[60], girdle[4], girdle[0]);
	var B = Facet(beta, girdle[4], girdle[12], girdle[8]);
	var C = Facet(beta, girdle[12], girdle[20], girdle[16]);
	
	// Создаем горизонтальнаую плоскость на уровне площадки
	var h_table = 0.5 * Math.tan (beta) * (1 - t);
	
	var table = new Plane3D();
	table.CreatePlaneNormalDistOXYZ(Z1, h_table + r/2);

	// Вектора идущие вдоль линий касательных к рундисту в его вершинах 4 и 12
	var dir_g4 = new Vector2D(girdle[5][0] - girdle[3][0], girdle[5][1] - girdle[3][1]);
	dir_g4.Normer();
	var dir_g12 = new Vector2D(girdle[13][0] - girdle[11][0], girdle[13][1] - girdle[11][1]);	
	dir_g12.Normer();
					  
	// Вектора идущие вдоль линий касательных к рундисту в его вершинах 0, 8 и 16
	var dir_g0 = new Vector2D(girdle[1][0] - girdle[63][0], girdle[1][1] - girdle[63][1]);
	dir_g0.Normer();				   
	var dir_g8 = new Vector2D(girdle[9][0] - girdle[7][0], girdle[9][1] - girdle[7][1]);
	dir_g8.Normer();			   
	var dir_g16 = new Vector2D(girdle[17][0] - girdle[15][0], girdle[17][1] - girdle[15][1]);
	dir_g16.Normer();			   
	
	// Плоскости проходящие перпендикулярно к касательным к рундисту в его вершинах 0, 8 и 16
	var vec_normal_g0 = new Vector3D(dir_g0[0], dir_g0[1], 0);
	vec_normal_g0.Normer();
	var pl_normal_g0 = new Plane3D();
	pl_normal_g0.CreatePlaneNormalVectorPoint(vec_normal_g0, girdle[0]);
	
	var vec_normal_g16 = new Vector3D(dir_g16[0], dir_g16[1], 0);
	vec_normal_g16.Normer();
	var pl_normal_g16 = new Plane3D();	
	pl_normal_g16.CreatePlaneNormalVectorPoint(vec_normal_g16, girdle[16]);
									  								  
	var vec_normal_g8 = new Vector3D(dir_g8[0], dir_g8[1], 0);
	vec_normal_g8.Normer();
	var pl_normal_g8 = new Plane3D();										  
	pl_normal_g8.CreatePlaneNormalVectorPoint(vec_normal_g8, girdle[8]);
									  
	//  Плоскости проходящие перпендикулярно к касательным к рундисту в его вершинах 4 и 12
	var vec_normal_g4 = new Vector3D(dir_g4[0], dir_g4[1], 0);
	vec_normal_g4.Normer();	
	var pl_normal_g4 = new Plane3D();
	pl_normal_g4.CreatePlaneNormalVectorPoint(vec_normal_g4, girdle[4]);
	
	var vec_normal_g12 = new Vector3D(dir_g12[0], dir_g12[1], 0);
	vec_normal_g12.Normer();	
	var pl_normal_g12 = new Plane3D();
	pl_normal_g12.CreatePlaneNormalVectorPoint(vec_normal_g12, girdle[12]);
											   
	// Находим вершины короны лежащие на уровне площадки
	crown[0] = table.IntersectionThreePlanes(A, pl_normal_g0);
	crown[2] = table.IntersectionThreePlanes(C, pl_normal_g16);

	// Это предварительное вычисление вершины crown[1]
	crown[1] = table.IntersectionThreePlanes(B, pl_normal_g8);

	// Вычисление по заданному значению Star Facet высоты средней
	// горизонтальной плоскости короны, которая определяет
	// высоту вершин 8, 9, 10, 11, 12, 13, 14 и 15.

	// Две вспомогательные плоскости, которые потребуются в процессе вычислений
	var plane_hor_1 = new Plane3D();
	plane_hor_1.CreatePlaneNormalDistOXYZ(Z1, 0.0);
	var plane_hor_2 = new Plane3D();
	plane_hor_2.CreatePlaneNormalDistOXYZ(Z1, 1.0);

	// Две вспомогательные точки для нахождения прямой определяемой пересечением
	// вспомогательных плоскостей с плоскостями в которых лежат грани A и B
	var point_1 = plane_hor_1.IntersectionThreePlanes(A, B);
	var point_2 = plane_hor_2.IntersectionThreePlanes(A, B);

	// Находим прямую, проходящую по линии пересечения плоскостей A и B
	var ln_A_B = new Line3D(point_1, point_2);

	// Вертикальная плоскость прохдящая касательно к рундисту в вершине girdle[4]
	var dir_n = new Vector3D(dir_g4[1], -dir_g4[0], 0.0);
	dir_n.Normer();
	var plane_tang_g4 = new Plane3D();
	plane_tang_g4.CreatePlaneNormalVectorPoint(dir_n, girdle[4]);	

	// Вертикальная плоскость проходящая через вершины короны 0 и 1 
	var plane_cr0_cr1 = new Plane3D();
	plane_cr0_cr1.CreatePlaneThreePoints(crown[1], crown[0],
	                 new Point3D(crown[0][0], crown[0][1], crown[0][2] + 1.0));

	//  Вспомогательная точка point_1, лежащая на линии пересечения 
	// плоскостей A, B и plane_tang_g4
	point_1 = plane_tang_g4.IntersectionThreePlanes(A, B);			

	//  Вспомогательная точка point_2, находящаяся в месте пересечения 
	// плоскости plane_cr0_cr1 и прямой ln_A_B
	point_2 = ln_A_B.IntersectionLinePlane(plane_cr0_cr1);	
	
	//  Средняя горизонтальная плоскость короны лежит между 
	// точками point_1 и point_2 и проходит через вершину короны 8.
	// Находим координаты короны 8 (требуется только высота этой вершины).
	var ht_8_2 = point_2[2] - (point_2[2] - point_1[2]) * starFacets;
				
	// Горизонтальная плоскость проходящая на уровне вершины 8 короны.
	var plane_hor_cr8 = new Plane3D(); 
	plane_hor_cr8.CreatePlaneNormalDistOXYZ(Z1, ht_8_2);

	// Пересчитываем координаты вершины 8 короны 
	// и находим координаты вершины 9 короны.
	crown[8] = plane_hor_cr8.IntersectionThreePlanes(A, pl_normal_g4);
	crown[9] = plane_hor_cr8.IntersectionThreePlanes(C, pl_normal_g12);

	// Новое положение плоскости в которой лежит грань B
	B.CreatePlaneThreePoints(girdle[8], crown[8], crown[9]);
	
	// Точки pt_mid_1 и pt_mid_2 лежат посередине между вершинами 8 и 9
	// короны но располагаются на разной высоте (произвольной).
	var pt_mid_1 = new Point3D((crown[8][0] + crown[9][0])/2, (crown[8][1] + crown[9][1])/2, 1);
	var pt_mid_2 = new Point3D((crown[8][0] + crown[9][0])/2, (crown[8][1] + crown[9][1])/2, 2);
					 
	// Строим вертикальную плоскость проходящую 
	// через точки pt_mid_1, pt_mid_2 и вершину короны 8.
	var pl_normal_g8 = new Plane3D(); 
	pl_normal_g8.CreatePlaneThreePoints(girdle[8], pt_mid_1, pt_mid_2);

	// Пересчитываем положение вершины 1 короны
	crown[1] = B.IntersectionThreePlanes(pl_normal_g8, table);
	
	// Координаты остальных вершин короны находятся из соображений
	// симметрии огранки относительно плоскостей OXZ и OYZ	
	crown[15] = new Point3D(-crown[8][0], crown[8][1], crown[8][2]);
	crown[14] = new Point3D(-crown[9][0], crown[9][1], crown[9][2]);
	crown[7] = new Point3D(-crown[1][0], crown[1][1], crown[1][2]);
	crown[6] = new Point3D(-crown[2][0], crown[2][1], crown[2][2]);
	crown[10] = new Point3D(crown[9][0], -crown[9][1], crown[9][2]);
	crown[3] = new Point3D(crown[1][0], -crown[1][1], crown[1][2]);
	crown[4] = new Point3D(crown[0][0], -crown[0][1], crown[0][2]);
	crown[5] = new Point3D(crown[7][0], -crown[7][1], crown[7][2]);
	crown[11] = new Point3D(crown[8][0], -crown[8][1], crown[8][2]);
	crown[12] = new Point3D(crown[15][0], -crown[15][1], crown[15][2]);
	crown[13] = new Point3D(crown[14][0], -crown[14][1], crown[14][2]);
	
	// Корректировка положения вершин рундиста по оси Z со стороны короны
	girdle[1] = corr_gd_crown(girdle[0], girdle[4], girdle[1], girdle[1+64], crown[8]);
	girdle[2] = corr_gd_crown(girdle[0], girdle[4], girdle[2], girdle[2+64], crown[8]);
	girdle[3] = corr_gd_crown(girdle[0], girdle[4], girdle[3], girdle[3+64], crown[8]);
	
	girdle[5] = corr_gd_crown(girdle[4], girdle[8], girdle[5], girdle[5+64], crown[8]);
	girdle[6] = corr_gd_crown(girdle[4], girdle[8], girdle[6], girdle[6+64], crown[8]);
	girdle[7] = corr_gd_crown(girdle[4], girdle[8], girdle[7], girdle[7+64], crown[8]);
	
	girdle[9] = corr_gd_crown(girdle[8], girdle[12], girdle[9], girdle[9+64], crown[9]);
	girdle[10] = corr_gd_crown(girdle[8], girdle[12], girdle[10], girdle[10+64], crown[9]);
	girdle[11] = corr_gd_crown(girdle[8], girdle[12], girdle[11], girdle[11+64], crown[9]);	
	
	girdle[13] = corr_gd_crown(girdle[12], girdle[16], girdle[13], girdle[13+64], crown[9]);
	girdle[14] = corr_gd_crown(girdle[12], girdle[16], girdle[14], girdle[14+64], crown[9]);
	girdle[15] = corr_gd_crown(girdle[12], girdle[16], girdle[15], girdle[15+64], crown[9]);	

	for (i = 1; i < 16; i++)
	{
		girdle[16+i][2] = girdle[16-i][2];
		girdle[48-i][2] = girdle[16-i][2];
		girdle[48+i][2] = girdle[16-i][2];
	}	
</pre>

<h3 align = "center"> Вычисляемые параметры короны огранки  </h3>
<p>
При принятом способе построения короны данной огранки, кроме параметров задающих форму рундиста, 
необходимо иметь три параметра непосредственно относящихся к короне:<br>
&emsp;1. Угол короны <b>Crown angle</b> который напрямую определяет наклон граней <b>A</b> и <b>C</b> короны и, косвенно, 
наклон грани <b>B</b>.<br>
&emsp;2. Ширина площадки <b>Table size</b>. <br>
&emsp;3. Параметр <b>Star facets</b> был рассмотрен выше.<br>

Эти три параметра представляют собой минимальный набор параметров, которые необходимы для построения короны. 
Они имеют отведенные им поля в структуре данных модели (<b>СДМ</b>). Эти поля носят названия <code>beta</code>,
<code>t</code> и <code>starFacets</code> соответственно. 
Для изменения высоты короны в огранке присутствуют два вычисляемых параметра <b>Crown height</b> и <b>Crown height 2</b>. 
Высота короны определяется следующим значением:<br>
&emsp;&emsp; crown_height = tan (beta) <b>·</b> (1 – t) / 2.
</p>
<p>
Как видно из приведенного выражения высота короны зависит одновременно и от значения параметра <code>beta</code> 
и от значения параметра <code>t</code>. Поэтому, если мы хотим изменить высоту короны, то сделать это можно двумя способами. 
При первом способе изменения высоты короны угол короны не меняется и величина <code>beta</code> остается постоянной. 
Если высоте короны было назначено новое значение <em>задавемая_высота_короны</em>, то при этом изменится ширина площадки, 
и она может быть вычислена по следующей формуле:<br>
&emsp;&emsp; t = 1 – 2 <b>·</b> (<em>задавемая_высота_короны</em>) / tan (beta).<br>
При втором способе изменения высоты короны ширина площадки остается неизменной, а  изменяется угол короны <code>beta</code>. 
Фактически при таком изменении угла короны происходит растяжение (или сжатие) короны вдоль оси <b>OZ</b> огранки. 
В этом случае новое вычисленное значение для угла короны <em>вычисленное_значение_beta</em> расчитывается по следующей формуле
<br>
&emsp;&emsp; <em>вычисленное_значение_beta</em> = atan (<em>задавемая_высота_короны</em>) / (0.5 – t/2).
<br>
В online-программе первому способу изменения высоты короны соответствует параметр <b>Crown height</b>, 
а второму – параметр <b>Crown height 2</b>.
</p>

<h3 align = "center"> Расчет положения вершин павильона  </h3>
<p>
Так как построение рундиста огранки и расстановка вершин на нем уже сделаны, мы можем построить плоскости, 
в которых лежат грани <b>a</b>, <b>b</b> и <b>c</b> павильона. Для нахождения уравнений этих плоскостей используются значения 
параметров <b>pav_ang_a</b>,  <b>pav_ang_b</b> и <b>pav_ang_c</b>. В <b>СДМ</b> этим параметрам соответствуют одноименные поля,
которые задают наклон граней <b>a</b>, <b>b</b> и <b>c</b> к горизонтальной плоскости <b>OXY</b>. 
Азимуты граней <b>a</b> и <b>c</b> определены тем фактом, 
что оси <b>OX</b> и <b>OY</b> расположены параллельно соответственно граням <b>a</b> и <b>c</b>.  
Азимут грани <b>b</b> задан направлением прямой проходящей через вершины рундиста <b>68</b> и <b>76</b>. 
Для определения уравнений плоскостей, в которых лежат грани <b>a</b>, <b>b</b> и <b>c</b>  
следует также задать по одной точке для каждой плоскости, через которую будет проходить рассматриваемая плоскость. 
В качестве таких точек выступают вершины рундиста <b>64</b>, <b>72</b> и <b>80</b>. 
</p>

<p>
Перейдем к определению положения наиболее близко расположенных к рундисту вершин павильона.  
Глубина вершины <b>1</b> павильона задается при помощи параметра <b>hA1</b>, которому в <b>СДМ</b> соответствует поле 
<code>hA1</code>. Для определения положения вершины <b>1</b> павильона проведем вспомогательную горизонтальную плоскость 
<b>planeHorA1</b> располгающуюся на глубине  <b>(- hA1 - r/2)</b>, где величина <b>r</b> является толщиной рундиста. 
Вершина павильона <b>1</b> определяется как точка пересечения плоскостей, в которых лежат грани 
павильона <b>a, b</b> и построенная горизонтальная плоскость. Положение вершины <b>2</b> павильона определяется 
как точка пересечения плоскостей граней <b>b</b> и <b>c</b> с этой же горизонтальной плоскостью.
</p>

<p>
Для нахождения положения вершин павильона <b>0</b>, <b>3</b> и <b>13</b> создадим три вертикальные 
(расположенные перпендикулярно плоскости <b>OXY</b>) вспомогательные плоскости 
<b>planeX0, planeY0</b> и <b>planeXY</b>. Плоскость <b>planeX0</b> проходит через ось <b>OX</b>, плоскость <b>planeY0</b> 
проходит через ось <b>OY</b>, а плоскость <b>planeXY</b> проходит через начало координат и вершину рундиста <b>72</b>.  
На глубине <b>(- hA0 - r/2)</b>, определенной параметром <b>hA0</b>, 
проводим горизонтальную плоскость. Вершина павильона <b>0</b> определяется как точка пересечения плоскостей <b>a</b>, 
<b>planeX0</b> и построенной горизонтальной плоскости. Вершина павильона <b>3</b> определяется подобным образом – 
как точка пересечения плоскостей <b>c, planeY0</b> и этой же горизонтальной плоскости.
</p>
<p>
Из рис.2 видно, что фактически павильон состоит из двух частей – верхней, примыкающей к рундисту, 
и нижней, заканчивающейся калетой огранки. Границей между двумя частями павильона служат вершины 
павильона <b>12, 13, 14, . . . 19</b>. Глубины вершин павильона <b>13</b>, <b>15</b>, <b>17</b> и <b>19</b> 
определяются значением параметра <b>hp1</b>. 
<br> 
&emsp;Глубина вершин павильона <b>12, 14, 16</b> и <b>18</b> также задается значением параметра <b>hp1</b>. 
Но для того чтобы была возможность сделать высоту указанных вершин не равной высоте вершин павильона
<b>13, 15, 17</b> и <b>19</b>, вводится параметр <b>del_hp1</b>, который позволяет изменить глубину этих 
вершин павильона и сделать ее отличной от глубины вершин <b>12, 14, 16</b> и <b>18</b>. 
<br>
&emsp;Для определения глубины вершин <b>13, 15, 17, 19</b> создается горизонтальная плоскость <b>pl_hp1</b> 
со значением координаты по оси <b>OZ</b> равным <b>(– hp1 – r/2)</b>. Положение вершины павильона <b>13</b> 
определяется как точка пересечения этой горизонтальной плоскости, плоскости грани <b>b</b> и плоскости <b>planeXY</b>. 
Для определения глубины вершин <b>12, 14, 16, 18</b> создается горизонтальная плоскость <b>pl_del_hp1</b>
глубина расположения которой по оси <b>Z</b> будет отличаться от глубины расположения 
плоскости <b>pl_hp1</b> на величину задаваемую параметром <b>del_hp1</b>.  Следовательно горизонтальная 
плоскость <b>pl_del_hp1</b> должна проходить на расстоянии <b>(– hp1 – del_hp1 – r/2)</b> от начала координат.
</p>
<p> 
С точки зрения симметрии павильона огранки желательно, чтобы в горизонтальной плоскости <b>OXY</b> 
вершины павильона <b>12, 13</b> и <b>14</b> располагались на одинаковом расстоянии от кaлеты если 
значение удлинения равно <b>1.0</b>. Для того чтобы удовлетворить этому требованию можно вычислить 
длину проекции на горизонтальную плоскость отрезка заключенного между началом координат 
и вершиной <b>13</b>. После этого строится вертикальная плоскость, проходящая параллельно плоскости <b>OXZ</b> 
на расстоянии найденной длины этой проекции. Построенная плоскость должна располагаться в области 
положительных значений оси <b>OY</b>. Очевидно, что вершина <b>12</b> будет принадлежать этой плоскости. 
Положение вершины <b>12</b> определяется как точка пересечения этой, только что созданной вертикальной 
плоскости с плоскостями <b>planeX0</b> и <b>pl_del_hp1</b>. 
<br>
&emsp;Координаты вершины <b>14</b> павильона находятся по точно такой же методике. Такой расчет положения 
вершин  <b>12</b> и <b>14</b> предполагает, что у данной огранки возможность изменения их положения 
фактически отсутствует. Положение указанных вершин в горизонтальной плоскости определяется неявно 
(глубину этих вершин определяет сумма значений <b>hp1</b> и <b>del_hp_1</b>) . 
<br>
&emsp;Если удлинение огранки отличается от <b>1.0</b>, например, в большую сторону, то расстояние от начала 
координат до вершины <b>14</b>, очевидным образом должно быть большим, чем расстояние от начала 
координат до вершины <b>12</b>. Однако данный метод построения не позволяет этого сделать.  
Поэтому резко сужается диапазон, в котором может изменяться выпуклость павильона. 
<br>
&emsp;Таким образом, мы нашли координаты всех вершин павильона для одного квадранта огранки. 
Остальные вершины павильона находятся из соображений симметрии огранки.
</p>
<pre class="prettyprint" id="quine">
	pavil[20] = new Point3D(0, 0, -r/2 - hp1 - hp2); // калетта 
	
	// Плоскости в которых лежат грани a, b и c павильона
	var a = Facet(- pav_ang_a, girdle[60+64], girdle[4+64], girdle[64]);
	var b = Facet(- pav_ang_b, girdle[4+64], girdle[12+64], girdle[8+64]);
	var c = Facet(- pav_ang_c, girdle[12+64], girdle[20+64], girdle[16+64]);
	
	// Проводим горизонтальную плоскость на уровне точки hA0
	var planeHorA0 = new Plane3D();
	planeHorA0.CreatePlaneNormalVectorPoint(Z1, new Point3D(0, 0, - hA0 - r/2));
							 
	// Проводим горизонтальную плоскость на уровне точки hA1
	var planeHorA1 = new Plane3D();
	planeHorA1.CreatePlaneNormalVectorPoint(Z1, new Point3D(0, 0, - hA1 - r/2));
	
	var planeX0 = new Plane3D();
	planeX0.CreatePlaneNormalDistOXYZ(X1, 0);
	
	var planeY0 = new Plane3D();
	planeY0.CreatePlaneNormalDistOXYZ(Y1, 0);
	
	var planeXY = new Plane3D();
	planeXY.CreatePlaneThreePoints(new Point3D(0,0,0), new Point3D(0,0,1), girdle[64+8]);
							  	
	pavil[0] = planeHorA0.IntersectionThreePlanes(a, planeX0);
	pavil[3] = planeHorA0.IntersectionThreePlanes(c, planeY0);	
	
	var pl_hp1 = new Plane3D();
	pl_hp1.CreatePlaneNormalDistOXYZ(Z1, - hp1 - r/2);
	pavil[13] = planeXY.IntersectionThreePlanes(b, pl_hp1);

	pavil[1] = planeHorA1.IntersectionThreePlanes(a, b);
	pavil[2] = planeHorA1.IntersectionThreePlanes(c, b);	
	
	var radius = Math.sqrt(pavil[13][0] * pavil[13][0] + pavil[13][1] * pavil[13][1]);
					 
	var pl_vert_A = new Plane3D();
	pl_vert_A.CreatePlaneNormalDistOXYZ(Y1, radius);
	var pl_vert_B = new Plane3D();
	pl_vert_B.CreatePlaneNormalDistOXYZ(X1, radius);
	
	// Проводим горизонтальную плоскость на уровне вершин павильона 12 и 14
	var pl_del_hp1 = new Plane3D();
	pl_del_hp1.CreatePlaneNormalVectorPoint(Z1, new Point3D(0, 0, - hp1 - del_hp1 - r/2));
		   
	pavil[12] = pl_del_hp1.IntersectionThreePlanes(pl_vert_A, planeX0);
	pavil[14] = pl_del_hp1.IntersectionThreePlanes(pl_vert_B, planeY0);
</pre>
<p>
Параметр <b>r</b> позволяет задавать исходное значение толщины рундиста. Грани короны и павильона, 
примыкающие к рундисту, при пересечении ими граней рундиста, уменьшают толщину рундиста на всем 
его протяжении, кроме тех мест, где расположены его узловые вершины  (<b>0, 4, 8, . . . 60</b> 
и <b>64, 68, . . . 124</b>). По этой причине  рундист становится неравномерным по своей толщине. 
Чем больше наклон граней короны и павильона, примыкающих к рундисту, тем более неравномерным 
по толщине становится рундист. Так как наклон граней павильона подходящих к рундисту обычно больше, 
чем наклон соответствующих граней короны, то на неравномерность рундиста  грани павильона влияют сильнее, 
чем грани короны. Для того чтобы хотя бы отчасти уменьшить эту неравномерность, в <b>СДМ</b>  
огранки введены еще три дополнительных поля <code>del_gd_1, del_gd_2</code> и <code>del_gd_3</code>.
</p>
<p>
Величина <code>del_gd_1</code> позволяет изменять глубину рундиста в его вершинах <b>64, 80, 96</b> и <b>112</b>, 
где передние и боковые четырехугольные фасеты павильона своей одной вершиной опираются на рундист.
<br>
&emsp;Величина <code>del_gd_2</code> позволяет изменять глубину рундиста в его вершинах <b>72, 88, 104</b> и <b>120</b>, 
где угловые четырехугольные фасеты павильона своей одной вершиной опираются на рундист.
<br>
&emsp;Величина <code>del_gd_3</code> позволяет изменять глубину рундиста в его вершинах 
<b>68, 76, 84, 92, 100, 108, 116, 124</b>. В этих вершинах ни одна из четырехугольных фасет 
павильона не опирается на рундист огранки, но они являются теми вершинами рундиста, 
в которых сходятся верхние клинья павильона.
</p>

<p>
Значения, которые задают эти значения этих тех полей в <b>СДМ</b>, вычитаются (складываются алгебраически) 
из исходного значения абсолютной величины глубины рундиста в соответствующих узловых вершинах павильона. 
Исходное значение толщины рундиста задается значением <b>r</b>. Поэтому  увеличение значения для любого 
из этих трех параметров ведет к уменьшению толщины рундиста в соответствующих вершинах. 
Путем изменения значений этих трех параметров можно попытаться, хотя бы визуально, 
сделать рундист более равномерным по толщине.
<br>
&emsp; Чтобы не загромождать данную <em>online</em>-программу для этих трех полей в <b>dat.GUI</b> было 
принято решение не вводить соответствующие параметры позволяющие изменять эти поля. Можно также 
исключить эти поля из <b>СДМ</b> и просто задать соответствующие им значения при вычислениях координат вершин.
</p>

<h3 align = "center"> Краткое резюме  </h3>
<p>
Модель огранки <em>Maltese</em>, которая была построена в данном разделе, следует рассматривать 
только как пример создания подобных огранок. Можно построить подобные огранки с другим количеством граней 
павильона и его рисунком. В построенной огранке при помощи задания различных значений параметров, 
определяющих форму павильона и рундиста, можно также придавать павильону вид, значительно отличающийся 
от вида получающегося при исходных значениях параметров.
<br>
&emsp; Для симметричности рисунка павильона в горизонтальной плоскости желательно чтобы его вершины <b>12</b> и <b>14</b> 
находились на одном и том же расстоянии от калетты в этой плоскости. Это требование ведет к тому, что в пределах
<em>выпуклости</em> модели значение <em>удлинения</em> огранки можно изменять только в очень <em>небольших</em> пределах.
Поэтому, так как предполагается, что огранка в большинстве случаев имеет длину равную ширине, можно считать 
ее симметричной относительно вертикальных плоскостей проходящих через оси <b>OX</b> и <b>OY</b>. 
И, следовательно, можно предположить, что значения параметров определяющих углы наклона фасет передней и 
боковой граней павильона <b>a</b> и <b>c</b> должны при их задании меняться одинаковым образом. 
И, значит, можно ограничиться всего одним параметром для задания угла наклона этих граней.
<br>
&emsp; То же самое относится к изменению значений следующих двух пар параметров определяющих форму рундиста и 
разбиение его на сегменты – (<b>rounnd_cir1, rounnd_cir2</b>) и (<b>ang_2, ang_3</b>). 
Значению параметра <b>ang_corner</b> можно придать постоянное значение равное <b>45°</b> и исключить его из <b>СДМ</b>. 
Учитывая названные выше пары параметров в общей сложности можно исключить четыре параметра из <b>СДМ</b>. 
В построенной огранке такое сокращение количества параметров не было произведено по причине того, 
что было желание продемонстрировать построение огранки, у которой можно было бы менять большинство 
элементов определяющих ее геометрию. Хотя следует сказать, что для передней и боковой фасеты павильона (<b>a</b> и <b>c</b>) 
был уже введен всего один параметр для задания одновременно глубин вершин павильона <b>1</b> и <b>3</b>, 
а не два различных параметра для раздельного задания их глубин.
</p>

<h3 align = "center">&emsp;&emsp;
<a href="../Cushion/Chapter_25.html"> <span class=brown>Глава 25 </span></a>  <span class=brown>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=brown> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=brown>► </span><a href="../Octagram/Chapter_27.html"> <span class=brown> Глава 27  </span></a>
</h3>

</body>
</html>
