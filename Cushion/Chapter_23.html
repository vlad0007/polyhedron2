<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Chapter 23 - Cushion girdle (part 1)</title>
	<link rel="stylesheet" type="text/css" href="../libs/style.css">
	<script src="../libs/run_prettify.js?autoload=true&amp;lang=css" defer=""></script>
	<script type = "text/javascript" src = "../libs/dat.gui.js"></script>
	<script src="../libs/WebGeometry.js"></script>
	<script src="../libs/canvas2D.js"></script>
	<script src="girdle1_A.js"></script>

	<style>
		div.out_girdle
		{
			position: relative;
			width: 900px;
			height: 600px;
			left: 5px;
			background-color: #ffffff;
			border: solid 2px;
		}
		
		div.gui_girdle
		{
			position: absolute;
			left: 0px;
			top: 505px;	
			height: 90px;
			width: 900px;
			background-color: #eeeeee;
			border: solid 1px;
		}
	</style>

</head>

<body>

<h3 align = "center">&emsp;&emsp;
<a href="../Briolette/Chapter_22.html"> <span class=brown>Глава 22 </span></a>  <span class=brown>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=brown> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=brown>► &ensp;</span><a href="../Cushion/Chapter_24.html"> <span class=brown> Глава 24  </span></a>
</h3>

<h2 align = "center"> Three.js и геометрия.  &ensp; Глава 23. &ensp; Построение рундиста огранки имеющей рундист в форме "подушки" (<em>cushion</em>). часть 1 </h2>
<p>
Направляющей линией для цилиндра рундиста является комбинация из восьми дуг окружностей. Программа в работе показана ниже.
</p>
<p>

<div class="out_girdle" id="out_girdle_01">  
		<canvas id="canvas_01" width="900" height="500" style="border: 1px solid"></canvas>
		<div class="gui_girdle" id="gui_container1" ></div> 
</div>

<h3 align = "center"> Построение и отрисовка на холсте кривой рундиста "подушки" (<em>cushion</em>)</h3>
<p>
Рундист огранки состоит из дуг восьми окружностей – четыре главные дуги окружности сопряжены по углам огранки четырьмя вспомогательными дугами. 
Используя ту особенность формы рундиста огранки, что она обладает симметрией по двум осям, достаточно рассмотреть построение 
одной четверти всей кривой представляющей собой рундист огранки. Рисунок <b>1</b> иллюстрирует это построение.  
Фактически оно сводится к сопряжению окружностей <b>cir1</b> и <b>cir2</b> дугой третьей окружности <b>cir3</b>. 
Окружность <b>cir3</b> имеет внутреннее касание к окружностям <b>cir1</b> и <b>cir2</b> в точках <b>F</b> и <b>G</b>. Термин <em>внутреннее касание</em> 
означает, что центры дуг окружностей <b>cir1</b>, <b>cir2</b> и <b>cir3</b> находятся по одну сторону от точек их касания.
</p>
<img src = "png_1.png" class="center-img-rounded" border = "1px">
<p>
Будем считать, что заданы радиусы <b>R1</b> и <b>R2</b> основных окружностей <b>cir1</b> и <b>cir2</b>, а также радиус сопрягающей окружности <b>R3</b>. 
Предположим также, что известно расположение центров <b>O1</b> и <b>O2</b> основных окружностей. 
Требуется найти положение центра <b>O3</b> сопрягающей окружности и координаты точек касания <b>F</b> и G</b></b>. 
Построение будем вести в нормированных величинах. Это значит, что ширина рундиста принимается равной величине <b>1</b>, 
а длина – величине, равной отношению длины огранки к ширине огранки. Также как и при построении других огранок 
обозначим величину этого отношения как <b>lw</b>.
</p>
<p>
Для нахождения центра <b>O3</b> окружности сопряжения <b>cir3</b> построим две вспомогательные окружности 
с радиусами равными значениям <b>R1 – R3</b> и <b>R2 – R3</b>. Центры этих вспомогательных  окружностей поместим 
в центры основных окружностей <b>O1</b> и <b>O2</b> соответственно. Тогда центр <b>O3</b> окружности <b>cir3</b> можно найти как точку 
пересечения вспомогательных окружностей.  Для нахождения точек пересечения окружности <b>cir3</b> 
с окружностями <b>cir1</b> и <b>cir2</b> создается окружность с центром <b>O3</b> и радиусом, 
отличающимся в большую сторону от <b>R3</b> на очень малую величину <em>epsilon</em> – радиус этой окружности 
равен <b>R3</b> + <em>epsilon</em>. Введение этой малой величины необходимо для того, чтобы в процессе проведения 
вычислений заведомо обеспечить пересечение соответствующих окружностей. 
В предельном случае, когда значение <em>epsilon</em> стремится к <b>0</b>, две точки пересечения сливаются 
и превращаются в одну точку касания окружностей. Пересечение окружности с радиусом равным (<b>R3</b> + <em>epsilon</em>) 
с окружностями <b>cir1</b> и <b>cir2</b> даст точки касания <b>F</b> и <b>G</b>. Теперь, когда мы знаем, как найти точки сопряжения дуг окружностей, 
из которых состоит огранка "подушка", можно перейти созданию программы для расчета формы рундиста огранки.
</p>
<p>
Из рисунка рис.<b>1</b> следует, что в программе построения огранки необходимо для построения линии рундиста иметь 
три параметра – радиусы трех окружностей (или, более точно, частей окружностей - дуг) - <b>cir1</b>, <b>сir2</b> и <b>cir3</b>. 
Как известно, размер любой окружности можно определить двумя способами – или задавая ее радиус, или задавая кривизну окружности. 
Под кривизной окружности понимается величина
<br>               
&emsp;&emsp;&emsp;&emsp;<b><em>K = 1 / R</em></b>,
<br>
где <b>R</b> является радиусом рассматриваемой окружности. При использовании кривизны для задания размера окружности, 
ее значение при больших радиусах окружности приближается к нулевому значению. Так как в огранке "подушка" 
величина радиусов <b>R1</b> и <b>R2</b> может принимать достаточно большие значения, 
то размеры окружностей <b>cir1</b> и <b>cir2</b> имеет смысл задавать путем указания величины их кривизны, 
чтобы не иметь дело с большими числами, относящимися к значениям радиусов. Однако на практике можно использовать  
еще один способ задания размеров окружностей.
Предположим, что размеры окружностей <b>cir1</b> и <b>cir2</b> рассчитываются по следующим формулам:
<br>
&emsp;&emsp;&emsp;&emsp;<b><em>R1 = (roundness_cir1)/2 + (lw ∙ lw)/(8 ∙ roundness_cir1)</em></b>
<br>
&emsp;&emsp;&emsp;&emsp;<b><em>R2 = (roundness_cir2)/2 + 1/(8 ∙ roundness_cir2)</em></b>
<br>
В этих выражениях значения величин <b>roundness_cir1</b> и <b>roundness_cir2</b> задают размеры окружностей. 
Они, можно сказать, совмещают в себе одновременно и радиус и кривизну соответствующих окружностей. 
Для того чтобы почувствовать, как работают <b>roundness_cir1</b> и <b>roundness_cir2</b>, следует положить значение <b>lw</b> равным <b>1</b>, 
а значения <b>roundness_cir1</b> и <b>roundness_cir2</b> сделать равными <b>0.5</b>. 
Тогда значения радиусов <b>R1</b> и <b>R2</b> станут равными также <b>0.5</b>. 
Принимая во внимание тот факт, что форму огранки мы рассчитываем в нормированных величинах, 
при которых ширина огранки по оси <b>OY</b> равна <b>1</b>, то при значениях <b>roundness_cir1</b> и <b>roundness_cir2</b> равных <b>0.5</b> 
форма огранки типа "подушка" превращается в окружность. Следовательно, для определения формы огранки типа "подушка" 
нам удобно задавать значения параметров <b>roundness_cir1</b> и <b>roundness_cir2</b> в пределах от <b>0</b> до <b>0.5</b>. 
Из приведенных выше рассуждений видно, что эти параметры действительно совмещают в себе определение размера окружности, 
как с точки зрения кривизны, так и с точки зрения радиуса окружности. 
Поэтому дадим этим параметрам специальное название – <em>округленность</em> (<em>roundness</em>).
</p>
<h3 align = "center"> Расстановка вершин на линии рундиста</h3>
<p>
Следующей, после построения формы рундиста, является задача разбиения рундиста на составляющие его грани.  
Обычно рундист делят на <b>64</b> отдельные грани (или сегмента).  Можно разбить рундист и на большее количество сегментов, 
но пока мы ограничимся значением равным <b>64</b> граням. Существует несколько способов позволяющих произвести такое разбиение. 
Простейшим из этих способов заключается в следующем. Предположим, что центр рундиста совпадает с началом системы координат <b>O</b>.  
Из точки O проведем лучи с шагом  <b>360°/64</b> и найдем точки пересечения этих лучей с рундистом огранки. 
Эти точки будут определять границы сегментов рундиста. Такой способ, хотя и является достаточно простым по реализации, 
тем не менее, не является наилучшим с точки зрения красоты огранки, 
которая получается в результате такого разбиения рундиста – чем больше форма рундиста отличается от окружности, 
тем менее эстетичным получается результат разбиения рундиста. 
Поэтому на практике такой способ деления рундиста на сегменты использовать не рекомендуется.
</p>
<p>
В самом общем случае все методы, которые реально используются, можно разделить по признаку того насколько разбиение рундиста 
на сегменты привязано (или не привязано) к построению короны или павильона огранки. 
Перечислим несколько возможных способов деления рундиста огранки "подушка" на сегменты. 
Каждый из этих способов деления рундиста можно выполнить с некоторыми вариациями, но суть их от этого не изменится.
</p>
<p> 
Рундист можно так рабить на сегменты, что расстановка точек на линии рундиста будет  зависеть ни от положения вершин короны, 
ни от положения вершин павильона. В этом случае деление рундиста на сегменты происходит независимо от построения остальных частей огранки. 
Но при этом разбиение производится с учетом того, что рундист состоит из восьми дуг окружностей 
и размер его сегментов определяется с учетом того, какой дуге окружности принадлежит рассматриваемый сегмент.
<br> 
&emsp;Можно таким образом разбить рундист на сегменты, чтобы расстановка узловых вершин на рундисте происходила одновременно 
с определением положения вершин короны, но не зависела при этом от положения вершин павильона.   
Такой метод разбиения рундиста позволяет в некоторых огранках получить более красивую форму короны при удлинениях огранки 
существенно отличающихся от значения равного <b>1</b>. В дальнейшем этот способ будет подробно разобран. 
<br>
&emsp;Существует еще метод разбиения рундиста на сегменты, когда положение вершин рундиста не зависит от положения вершин короны, 
но зависит от координат некоторых вершин павильона. Этот способ разбиения иногда применяют при наличии 
на павильоне достаточно протяженных вдоль рундиста граней.
<br>
&emsp;Иногда при построении некоторых огранок (и это относится не только к огранкам типа "подушка") требуется сделать так, 
чтобы узловые вершины рундиста со стороны короны не совпадали по своему положению в горизонтальной плоскости 
с узловыми вершинами рундиста расположенными со стороны павильона. 
В этом случае расстановка вершин на рундисте производится отдельно для его вершин находящихся на стороне короны 
и для его вершин со сторны павильона. В результате такого разбиения рундиста на нем появляются дополнительные сегменты. 
В дальнейшем мы рассмотрим построение огранки "подушка" <em>Octagram</em> с таким рундистом.
</p>
<h3 align = "center">Разбиение рундиста "подушки" на сегменты, размер и положение которых не зависит ни от вида короны, ни от вида павильона</h3>
<p>
</p>
При использовании рассмотренного ниже способа расстановки вершин на рундисте огранки "подушка" координаты вершин определяются 
вне зависимости от того какую форму имеют корона и павильон. Этот метод используется наиболее часто. 
Деление рундиста на сегменты в огранках, построение которых было осуществлено в предыдущих разделах – бриллиант, маркиз, груша и сердце, 
также производилось безотносительно к тому, какую форму у этих огранок имели корона и павильон. 
В некотором отношении такой способ разбиения рундиста является наиболее предпочтительным. 
Связано это с тем, что при таком способе его построения, координаты вершин короны и павильона огранки зависят 
только положения вершин рундиста, но не зависят напрямую от положения вершин друг друга и, поэтому, в программах, 
оптимизирующих размер и форму огранок, появляется возможность оптимизировать корону и павильон независимо друг от друга. 
Геометрические построения, соответствующие такому способу разбиения рундиста показаны на рисунке <b>2</b>. 
Этот рисунок во многом повторяет рисунок <b>1</b>, но в нем отражены еще дополнительные моменты, 
которые относятся именно к разбиению рундиста на сегменты.
</p>
<img src = "png_2.png" class="center-img-rounded" border = "1px">
<p>
Разбиение производится следующим образом. Сначала определяются размеры и положение на рундисте его главных сегментов. 
Для первой четверти огранки рундиста обозначим их как <b>seg1, seg2, seg3</b> и <b>seg4</b>.  
Через точку <b>O3</b>, являющуюся центром окружности сопряжения, проводим прямую параллельную оси <b>OX</b>. 
Относительно этой прямой определим значение угла <b>ang_corner</b>, которое задаст положение  точки <b>U</b>. 
Эта точка соответствует угловой вершине <b>8</b> рундиста, которая делит первую четверть рундиста огранки на две части. 
Одна часть включает в себя сегменты <b>seg1, seg2</b>, а другая – <b>seg3</b> и <b>seg4</b>. Назовем эту вершину угловой вершиной рундиста.
</p>
<p> 
Через точку <b>O3</b> и точку <b>U</b> проведем прямую, относительно которой будем отсчитывать значение углов <b>ang2</b> и <b>ang3</b>. 
Эти углы определят размер сегментов <b>seg2</b> и <b>seg3</b> и опосредованно – размер сегментов <b>seg1</b> и <b>seg4</b>. 
Границам  этих сегментов соответствуют точки <b>S</b> и <b>V</b>.  
Точке S соответствует вершина <b>4</b> рундиста, а точке <b>V</b> – вершина <b>12</b> рундиста. 
Координаты точек <b>S</b> и <b>V</b> рассчитываются как точки пересечения лучей исходящих из точки <b>O4</b> 
и проходящих через вспомогательные, предварительно определенные точки <b>T</b> и <b>W</b>, с линией рундиста.  
Направление лучей, проходящих через точки <b>T</b> и <b>W</b>, задается углами <b>ang2</b> и <b>ang3</b>. 
</p>
<p>
Особым образом задаются координаты точки <b>O4</b>. Можно было бы совместить положение этой точки с положением 
центра сопрягающей окружности <b>O3</b>. Но в этом случае размер сегментов оказался бы связанным с радиусом сопрягающей окружности <b>R3</b>. 
Поэтому зададим положение точки <b>O4</b> таким образом, чтобы координаты этой точки оказались привязаны к длине и ширине огранки 
через значение введенного нами параметра, который в <b>СДО</b> имеет поле <code>gd_segments</code>. 
Мы примем, что ордината точки <b>O4</b> равна значению &nbsp;<b><em>gd_segments</em></b>&nbsp;, 
а абсцисса этой точки равна &nbsp;<b><em>gd_segments ∙ lw</em></b>&nbsp;. 
Таким образом, чем меньше мы делаем значение <code>gd_segments</code>, тем дальше мы удаляем точку <b>O4</b> от угловой части рундиста и, 
тем самым, мы увеличиваем размер угловых его сегментов <b>seg2</b> и <b>seg3</b> и одновременно уменьшаем при этом размер сегментов <b>seg1</b> и <b>seg4</b>.
<br>
&emsp; В <em>online</em> программе данной главы точка <b>O4</b> не присутствует. Программа, в которой точка <b>O4</b> используется
для определения границ сегментов, приведена в следующей главе. Сравнив эти две программы можно увидеть в чем заключается
преимущество варианта программы с введенной точкой <b>O4</b>.
</p>
<p>
После того как размеры сегментов <b>seg1, seg2, seg3, seg4</b> и их положение на рундисте определены, 
следующей задачей является деление каждого из четырех названных сегментов еще раз на четыре части. 
Осуществим такое деление путем определения точек пересечения лучей проведенных из центров окружностей <b>O1</b> и <b>O2</b> с линией рундиста огранки.
</p>
<p>
Из рассмотрения рисунка <b>3</b> видно, что, прежде всего, требуется найти величину углов <b>&phi;1, &phi;2, &phi;3</b> и <b>&phi;4</b>. 
Эти углы задают границы секторов, в пределах которых будут проходить лучи осуществляющие деление 
сегментов <b>seg1, seg2, seg3</b> и <b>seg4</b>. Так как координаты точек <b>S, U</b> и <b>V</b> уже определены, 
то зная координаты центров окружностей <b>O1</b> и <b>O2</b>, нахождение значений углов <b>&phi;1, &phi;2, &phi;3</b> и <b>&phi;4</b> не составляет труда. 
Как производится деление каждого сегмента на четыре части, можно увидеть из приведенного ниже листинга, 
В этой функции осуществляется построение рундиста огранки "подушка" описанным выше способом и его деление на <b>64</b> сегмента. 
В функцию передается массив из <b>64</b> элементов, предназначенный для хранения двумерных координат вершин рундиста. 
</p>
<p>
В процессе своей работы функция заполняет эти элементы рассчитанными значениями координат вершин рундиста. 
Для того, чтобы продемонстрировать приведенный выше способ построения рундиста огранки "подушка" можно создать простейшую <b>3D</b>-модель, 
которая будет состоять только из сегментов рундиста, и двух дополнительных вершин расположенных сверху и снизу огранки по ее центру. 
Трехмерная модель огранки рундиста приведена на рисунке <b>3</b>. 
</p>
<img src = "png_3.png" class="center-img-rounded" border = "1px">
<br><br>
&emsp; Исходный текст функции осуществляющей построение рундиста "подушки":
<pre class="prettyprint" id="quine">
function init_girdle()
{
	var i;
	
	// вспомогательные точки
	var point1 = new Point2D(); 
	var point2 = new Point2D();
	
	// Радиус большей окружности
	R1 = rounnd_cir1/2.0 + (lw * lw)/(8.0*rounnd_cir1);
	// Центр большей окружности - лежит на оси OY
	O1 = new Point2D(0, 0.5 - R1);
	// Большая окружность
	var cir1 = new Circle2D(O1, R1);

	// Радиус меньшей окружности
	R2 = rounnd_cir2/2.0 + 1/(8.0*rounnd_cir2);
	// Центр меньшей окружности - лежит на оси OX
	O2 = new Point2D(lw/2 - R2, 0);
	// Меньшая окружность
	var cir2 = new Circle2D(O2, R2);

	//  Окружности, используемые для вычисления центра 
	// сопрягающей окружности
	R2_R3 = new Circle2D(O2, R2 - R3); 
	R1_R3 = new Circle2D(O1, R1 - R3); 

	// Центр сопрягающей окружности
	O3 = new Point2D(); 
	if(!R2_R3.IntersectionTwoCircles(R1_R3, point1, point2))
	{
		return null;
	}
	if (point1[0] > point2[0])
	{
		O3[0] = point1[0]; O3[1] = point1[1]
	}
	else
	{
		O3[0] = point2[0]; O3[1] = point2[1]			
	}

	// Создаем сопрягающую окружность чуть большего 
	// радиуса чем R3 (для проверки)
	var cir3 = new Circle2D(O3, R3 + 0.00001); // R3 + EPSILON);

	// Проверяем пересекаются или нет окружности 
	// cir2 и cir1 с сопрягающей окружностью cir3
	// Координаты точек пересечения g и point2
	// и также f и point2 должны отличаться совершенно незначительно
	G = new Point2D(); // Точки пересечения окружностей cir1
	F = new Point2D(); // и cir2 с сопрягающей окружностью cir3
	
	if(!cir2.IntersectionTwoCircles(cir3, G, point2))
	{
		return null;
	}
	if(!cir1.IntersectionTwoCircles(cir3, F, point2)) 
	{
		return null;
	}

	// Находим положение точки на луче, 
	//который будет определять направление на котором  
	//лежит угловая вершина рундиста girdle[8]. 
	// Этот луч будет использоваться в качестве 
	//начальной прямой отсчета для углов ang_2 и ang_3.

	var u = new Point2D();
	u[0] = O3[0] + Math.cos(ang_corner) * R3;
	u[1] = O3[1] + Math.sin(ang_corner) * R3;

	var t = new Point2D();	// Точки на радиусах сопрягающей окружности cir3
	var w = new Point2D();	// На рисунке они лежат на сопрягающей окружности
	t[0] = O3[0] + Math.cos(ang_corner + ang_2);
	t[1] = O3[1] + Math.sin(ang_corner + ang_2);

	w[0] = O3[0] + Math.cos(ang_corner - ang_3);
	w[1] = O3[1] + Math.sin(ang_corner - ang_3);

	// Прямые используемые для нахождения границ сегментов рундиста.
	var ln_O3_t = new Line2D(O3, t);
	var ln_O3_u = new Line2D(O3, u);
	var ln_O3_w = new Line2D(O3, w);

	//  Конструируем верхнюю часть рундиста
	var s = new Point2D(); // s, v - Точки лежащие на границе сегментов seg1 и seg2
	var v = new Point2D(); // и также на границе сегментов seg3 и seg4
	girdle[0] = new Point2D(0, 0.5);

	if(!cir1.IntersectionLineCircle(ln_O3_t, point1, point2))
	{
		return null;
	}
	if (point1[1] > point2[1])
	{
		s[0] = point1[0]; s[1] = point1[1]
	}
	else
	{
		s[0] = point2[0]; s[1] = point2[1]			
	}
	girdle[4] = s;
	girdle[8] = u;

	if(!cir2.IntersectionLineCircle(ln_O3_w, point1, point2))
	{
		return null;
	}
	if (point1[0] > point2[0])
	{
		v[0] = point1[0]; v[1] = point1[1]
	}
	else
	{
		v[0] = point2[0]; v[1] = point2[1]			
	}
	
	girdle[12] = v;
	girdle[16]= new Point2D(lw/2, 0);

	// Координаты остальных вершин рундиста
	var x, y;
	var Fi2 = Math.atan2((u[0] - O1[0]), (u[1] - O1[1]));
	var Fi1 = Math.atan2((s[0] - O1[0]), (s[1] - O1[1]));
	var ang = Fi2;
	var dAng = (Fi2 - Fi1)/4; // Угловой шаг

	// seg2
	for(i = 7; i > 4; i--)
	{
		ang = ang - dAng;
		x = Math.sin(ang)*R1 + O1[0];
		if(x > F[0]) // Правее точки пересечения окружностей cir1 и cir3
		{
			// Пересечение с сопрягающей окружностью cir3
			var line2 = new Line2D();
			var vector2 = new Vector2D(Math.sin(ang), Math.cos(ang));
			line2.CreateLineVectorPoint(vector2, O1);
			if(!cir3.IntersectionLineCircle(line2, point1, point2))
				return null;
			if (point1[1] > point2[1])
			{
				y = point1[1];
				x = point1[0];
			}
			else
			{
				y = point2[1];
				x = point2[0];
			}
		}
		else
		{
			y = Math.cos(ang)*R1 + O1[1];
		}
		girdle[i] = new Point2D(x, y);
	}

	ang = Fi1;
	dAng = Fi1 / 4;
	// seg1
	for(i = 3; i > 0; i--)
	{
		ang = ang - dAng;
		x = Math.sin(ang)*R1 + O1[0];
		if(x > F[0]) // Правее точки пересечения окружностей cir1 и cir3
		{
			// Пересечение с сопрягающей окружностью cir3
			var line1 = new Line2D();
			var vector1 = new Vector2D(Math.sin(ang), Math.cos(ang));
			line1.CreateLineVectorPoint(vector1, O1);
			if(!cir3.IntersectionLineCircle(line1, point1, point2))
			{
				return null;
			}
			if (point1[1] > point2[1])
			{
				y = point1[1];
				x = point1[0];
			}
			else
			{
				y = point2[1];
				x = point2[0];
			}
		}
		else
		{
			y = Math.cos(ang)*R1 + O1[1];
		}
		girdle[i] = new Point2D(x, y);
	}

	var Fi3 = Math.atan2((u[1] - O2[1]), (u[0] - O2[0]));
	var Fi4 = Math.atan2((v[1] - O2[1]) ,(v[0] - O2[0]));
	ang = Fi3;
	dAng = (Fi3 - Fi4)/4;

	// seg3
	for(i = 9; i < 12; i++)
	{
		ang = ang - dAng;
		y = Math.sin(ang)*R2 + O2[1];
		if(y > G[1]) // Выше точки пересечения окружностей cir2 и cir3
		{
			// Пересечение с сопрягающей окружностью cir3
			var line3 = new Line2D();
			var vector3 = new Vector2D(Math.cos(ang), Math.sin(ang));
			line3.CreateLineVectorPoint(vector3, O2);
			if(!cir3.IntersectionLineCircle(line3, point1, point2))
			{
				return null;
			}
			if (point1[0] > point2[0])
			{
				x = point1[0];
				y = point1[1];
			}
			else
			{
				x = point2[0];
				y = point2[1];
			}
		}
		else
		{
			x = Math.cos(ang)*R2 + O2[0];
		}					
		girdle[i] = new Point2D(x, y);
	}

	ang = Fi4;
	dAng = Fi4 / 4;

	// seg4
	for(i = 13; i < 16; i++)
	{
		ang = ang - dAng;
		y = Math.sin(ang)*R2 + O2[1];
		if (y > G[1]) // Выше точки пересечения окружностей cir2 и cir3
		{
			// Пересечение с сопрягающей окружностью cir3
			var line4 = new Line2D();
			var vector4 = new Vector2D(Math.cos(ang), Math.sin(ang));
			line4.CreateLineVectorPoint(vector4, O2);
			if(!cir3.IntersectionLineCircle(line4, point1, point2))
			{
				return null;
			}
			if (point1[0] > point2[0])
			{
				x = point1[0];
				y = point1[1];
			}
			else
			{
				x = point2[0];
				y = point2[1];
			}
		}
		else
		{
			x = Math.cos(ang)*R2 + O2[0];
		}
		girdle[i] = new Point2D(x, y);
	}

	// Производим вычисления вершин рундиста для остальных квадрантов
	for(i = 0; i < 16; i++)
	{
		girdle[32-i] = new Point2D();
		girdle[32-i][0] = girdle[i][0];
		girdle[32-i][1] = -girdle[i][1];
	}
	for(i = 1; i < 32; i++)
	{
		girdle[64-i] = new Point2D();
		girdle[64-i][0] = -girdle[i][0];
		girdle[64-i][1] = girdle[i][1];
	}
}
</pre>

<h3 align = "center">&emsp;&emsp;
<a href="../Briolette/Chapter_22.html"> <span class=brown>Глава 22 </span></a>  <span class=brown>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=brown> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=brown>► </span><a href="../Cushion/Chapter_24.html"> <span class=brown> Глава 24  </span></a>
</h3>

</body>
</html>
